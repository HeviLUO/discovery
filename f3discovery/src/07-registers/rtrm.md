# RTRM: 阅读参考手册

我提到微控制器有几个引脚。为了方便起见，这些引脚被分组在16个引脚的*端口*中。
每个端口用一个字母命名： 端口A、端口B等，每个端口内的引脚用0到15之间的数字命名。

我们首先要弄清楚的是哪个引脚连接到哪个LED。此信息在STM32F3DISCOVERY[用户手册中] (您下载了一份副本，对吗？)。
在本节中：

[用户手册中]: http://www.st.com/resource/en/user_manual/dm00063382.pdf

> 第6.4节LED-第18页

手册上说：

- `LD3`，北面的LED，连接到引脚`PE9`。`PE9`是端口E上的引脚9的缩写。
- `LD7`， 东面的LED，连接到引脚`PE11`。

到目前为止，我们知道我们想要改变引脚PE9和PE11的状态以打开/关闭 北/东LED。
这些引脚是端口E的一部分，因此我们必须处理`GPIOE`外围设备。

每个外围设备都有一个与其相关的寄存器块。寄存器块是在连续存储器中分配的寄存器的集合。
寄存器块开始的地址称为其基址。我们需要弄清楚`GPIOE`外设的基址是什么。该信息在微控制器[参考手册]以下章节中：

[参考手册]: http://www.st.com/resource/en/reference_manual/dm00043574.pdf

> 第3.2.2节内存映射和寄存器边界地址-第51页

该表显示`GPIOE`寄存器块的基址为`0x4800_1000`。

每个外围设备在文档中也有自己的部分。这些部分中的每一个都以外围设备寄存器块包含的寄存器表结尾。
对于`GPIO`系列外设，该表位于：

> 第11.4.12节GPIO寄存器映射-第243页

'BSRR'是我们将用于设置/重置的寄存器。其偏移值为'GPIOE'基址的'0x18'。
我们可以在参考手册中查找BSRR。GPIO 寄存器 -> GPIO 端口位 设置/重置 寄存器 (GPIOx_BSRR)。

现在我们需要跳转到特定寄存器的文档。上面有几页：

> 第11.4.7节GPIO端口位设置/复位寄存器（GPIOx_BSRR）-第240页

最后！

这是我们写的注册表。文档中有一些有趣的内容。首先，这个寄存器是只读的...
所以让我们尝试读取它的值`:-)`。

我们将使用GDB's `examine`命令：`x`。

```
(gdb) next
16              *(GPIOE_BSRR as *mut u32) = 1 << 9;

(gdb) x 0x48001018
0x48001018:     0x00000000

(gdb) # the next command will turn the North LED on
(gdb) next
19              *(GPIOE_BSRR as *mut u32) = 1 << 11;

(gdb) x 0x48001018
0x48001018:     0x00000000
```

读取寄存器返回`0`。这与文档中的内容相符。

文档中提到的另一件事是，位0到15可以用来设置相应的引脚。即位0设置管脚0。
这里，*设置*表示在管脚上输出*高*值。

文档还指出，位16至31可用于重置相应的引脚。在这种情况下，位16重置管脚编号0。
正如您可能猜到的，*重置*意味着在管脚上输出一个*低*值。

将这些信息与我们的计划联系起来，似乎都是一致的：

- 将 `1 << 9` (`BS9 = 1`)  写入 `BSRR`  将 `PE9` 设置为 *high*。这将*打开*北面的LED。

- 将 `1 << 11` (`BS11 = 1`) 写入 `BSRR` 将 `PE11` 设置为 *high*。这将*打开*东面的LED。

- 将 `1 << 25` (`BR9 = 1`) 写入 `BSRR` 将 `PE9` 设置为 *low*。这将*关闭*北面的LED。

- 最后，将 `1 << 27` (`BR11 = 1`) 写入 `BSRR` 将 `PE11`设置为 *low*。这将*关闭*东面的LED。
